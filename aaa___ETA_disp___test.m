function pass_part_fail=aaa___ETA_disp___test(varargin)
%This is not a true test suite, but it should confirm the function runs without errors.
%
%Pass:    passes all tests
%Partial: [no partial passing condition]
%Fail:    fails any test
pass_part_fail='pass';

if nargin==0,RunTestHeadless = false;else,RunTestHeadless = true;end
ThrowError = false;

try
    % In a headless context, catch the output to avoid a clc call.
    if RunTestHeadless,catch_output = cell(1);else,catch_output = cell(0);end
    % Only run the first example, as the second one takes a fairly long time and doesn't provide
    % any additional value in terms of testing.
    N = 10;then = now; %#ok<TNOW1>
    for n=1:N
        pause((1+rand)/N)
        [catch_output{:}] = ETA_disp(N,n,then);
    end
catch
    ME = lasterror; %#ok<LERR>
    ThrowError = true;
end

if ~ThrowError
    then = now-0.001; %#ok<TNOW1>
    s1 = ETA_disp(2,1,then);              % Uses time per iteration.
    s2 = ETA_disp(2000,1000,then);        % Uses iterations per second.
    s3 = ETA_disp(2000,1000,then,[],10);  % Overestimates the time.
    s4 = ETA_disp(2,1,now-1); %#ok<TNOW1> % ETA in a day.
    s = [s1;s2;s3;s4];
    s(:,2) = []; % This depends on current time, so remove it before hashing.

    checkpoint('aaa___ETA_disp___test','ComputeNonCryptHash')
    if ~strcmp(ComputeNonCryptHash(s,32,'-v2'),'9DA8A9A8')
        ThrowError = true;
        try error('hash did not match expected result'),catch,ME=lasterror;end %#ok<LERR>
    end
end

if ~ThrowError
    try
        then = now-0.001; %#ok<TNOW1>
        [ignore,s1] = ETA_disp(2,1,then);             %#ok<ASGLU> % Uses time per iteration.
        [ignore,s2] = ETA_disp(2000,1000,then);       %#ok<ASGLU> % Uses iterations per second.
        [ignore,s3] = ETA_disp(2000,1000,then,[],10); %#ok<ASGLU> % Overestimates the time.
        [ignore,s4] = ETA_disp(2,1,now-1);      %#ok<ASGLU,TNOW1> % ETA in a day.
        s = [s1;s2;s3;s4];
        % These depend on the current date/time, so remove them before hashing.
        s = rmfield(s,{'t_sec','it_per_sec','ETA','ETA_date'});

        checkpoint('aaa___ETA_disp___test','ComputeNonCryptHash')
        if ~strcmp(ComputeNonCryptHash(s,32,'-v2'),'C7A8F8D4')
            ThrowError = true;
            try error('hash did not match expected result'),catch,ME=lasterror;end %#ok<LERR>
        end
    catch,ME=lasterror;%#ok<LERR>
    end
end

SelfTestFailMessage = '';
% No self-validators found for this function.
checkpoint('read'); % Force write-out to checkpoint file.

if ThrowError || ~isempty(SelfTestFailMessage)
    if nargout==1
        pass_part_fail='fail';
    else
        if ~isempty(SelfTestFailMessage)
            error('Self-validator functions returned these error(s):\n%s',SelfTestFailMessage)
        else
            checkpoint('aaa___ETA_disp___test','char2cellstr','get_trace')
            trace = char2cellstr(get_trace(0,ME.stack));
            error('Test failed with error message:%s',...
                sprintf('\n    %s',ME.message,trace{:}))
        end
    end
end
disp(['tester function ' mfilename ' finished '])
if nargout==0,clear,end
end
function out=bsxfun_plus(in1,in2)
% Implicit expansion for plus(), but without any input validation.
persistent type
if isempty(type)
    checkpoint('bsxfun_plus','hasFeature')
    type = ...
        double(hasFeature('ImplicitExpansion')) + ...
        double(hasFeature('bsxfun'));
end
if type==2
    % Implicit expansion is available.
    out = in1+in2;
elseif type==1
    % Implicit expansion is only available with bsxfun.
    out = bsxfun(@plus,in1,in2);
else
    % No implicit expansion, expand explicitly.
    % Determine size and find non-singleton dimensions.
    sz1 = ones(1,max(ndims(in1),ndims(in2)));
    sz2 = sz1;
    sz1(1:ndims(in1)) = size(in1);
    sz2(1:ndims(in2)) = size(in2);
    L = sz1~=1 & sz2~=1;
    if ~isequal(sz1(L),sz2(L))
        error('HJW:bsxfun_plus:arrayDimensionsMustMatch',...
            'Non-singleton dimensions of the two input arrays must match each other.')
    end
    if min([sz1 sz2])==0
        % Construct an empty array of the correct size.
        sz1(sz1==0) = inf;sz2(sz2==0) = inf;
        sz = max(sz1,sz2);
        sz(isinf(sz)) = 0;
        % Create an array and cast it to the correct type.
        out = feval(str2func(class(in1)),zeros(sz));
        return
    end
    in1 = repmat(in1,max(1,sz2./sz1));
    in2 = repmat(in2,max(1,sz1./sz2));
    out = in1+in2;
end
end
function c=char2cellstr(str,LineEnding)
% Split char or uint32 vector to cell (1 cell element per line). Default splits are for CRLF/CR/LF.
% The input data type is preserved.
%
% Since the largest valid Unicode codepoint is 0x10FFFF (i.e. 21 bits), all values will fit in an
% int32 as well. This is used internally to deal with different newline conventions.
%
% The second input is a cellstr containing patterns that will be considered as newline encodings.
% This will not be checked for any overlap and will be processed sequentially.

returnChar = isa(str,'char');
str = int32(str); % Convert to signed, this should not crop any valid Unicode codepoints.

if nargin<2
    % Replace CRLF, CR, and LF with -10 (in that order). That makes sure that all valid encodings
    % of newlines are replaced with the same value. This should even handle most cases of files
    % that mix the different styles, even though such mixing should never occur in a properly
    % encoded file. This considers LFCR as two line endings.
    if any(str==13)
        checkpoint('char2cellstr','PatternReplace')
        str = PatternReplace(str,int32([13 10]),int32(-10));
        str(str==13) = -10;
    end
    str(str==10) = -10;
else
    for n=1:numel(LineEnding)
        checkpoint('char2cellstr','PatternReplace')
        str = PatternReplace(str,int32(LineEnding{n}),int32(-10));
    end
end

% Split over newlines.
newlineidx = [0 find(str==-10) numel(str)+1];
c=cell(numel(newlineidx)-1,1);
for n=1:numel(c)
    s1 = (newlineidx(n  )+1);
    s2 = (newlineidx(n+1)-1);
    c{n} = str(s1:s2);
end

% Return to the original data type.
if returnChar
    for n=1:numel(c),c{n} =   char(c{n});end
else
    for n=1:numel(c),c{n} = uint32(c{n});end
end
end
function tf=CharIsUTF8
% This provides a single place to determine if the runtime uses UTF-8 or UTF-16 to encode chars.
% The advantage is that there is only 1 function that needs to change if and when Octave switches
% to UTF-16. This is unlikely, but not impossible.
persistent persistent_tf
if isempty(persistent_tf)
    checkpoint('CharIsUTF8','ifversion')
    if ifversion('<',0,'Octave','>',0)
        % Test if Octave has switched to UTF-16 by looking if the Euro symbol is losslessly encoded
        % with char.
        % Because we will immediately reset it, setting the state for all warnings to off is fine.
        w = struct('w',warning('off','all'));[w.msg,w.ID] = lastwarn;
        persistent_tf = ~isequal(8364,double(char(8364)));
        warning(w.w);lastwarn(w.msg,w.ID); % Reset warning state.
    else
        persistent_tf = false;
    end
end
tf = persistent_tf;
end
function[v000,varargout]=ComputeNonCryptHash(v001,varargin),if nargin<1,...
error('HJW:ComputeNonCryptHash:InputIncorrect','At least 1 input required.'),end,if nargout>=2,...
varargout=cell(nargout-1,1);end,if nargin==2&&isa(varargin{1},...
'struct')&&varargin{1}.SkipInputParse,v002=varargin{1};else,[v003,v002,v004]=...
ComputeNonCryptHash_f10(varargin{:});if v003,v002=ComputeNonCryptHash_f13(v002);if nargout>=2,...
v002.SkipInputParse=true;varargout{1}=v002;end,else,ComputeNonCryptHash_f15(v002.print_to,v004),...
end,end,v005=v002.HashLength;v006=v002.Version;try v004=[];v001=ComputeNonCryptHash_f04(v001,...
v002);catch v004;if isempty(v004),v004=lasterror;end,if strcmp(v004.identifier,'MATLAB:nomem'),...
ComputeNonCryptHash_f15(v002.print_to,v004),else,if isfield(v002,'debug')&&v002.debug,v007=...
sprintf('\n[original error: %s %s]',v004.identifier,v004.message);else,v007='';end,...
ComputeNonCryptHash_f15(v002.print_to,'HJW:ComputeNonCryptHash:UnwindFailed',...
['The nested input contains an unsupported data type.' v007]),end,end,if mod(numel(v001),...
v005/16),v008=uint16(1:v005/16).';v008(1:mod(numel(v001),v005/16))=[];v001=[v001;v008];end,if ...
v006==1,v001=ComputeNonCryptHash_f03(v001);v001=ComputeNonCryptHash_f21(v001);v001=xor(v001,...
reshape(v001,[],16).');else,v001=ComputeNonCryptHash_f03(v001);v001=...
ComputeNonCryptHash_f21(v001);v001=ComputeNonCryptHash_f17(v001);end,v001=mod(sum(reshape(v001,...
v005,[]),2),2);v001=ComputeNonCryptHash_f02(v001);if v002.isSaltCall,v000=v001;return,end,v001=...
ComputeNonCryptHash_f18(v001,v002);v000=ComputeNonCryptHash_f01(v001);v000=reshape(v000.',1,[]);
end
function v000=ComputeNonCryptHash_f00(v001),persistent v002,if isempty(v002),v002=struct('HG2',...
ComputeNonCryptHash_f23('>=','R2014b','Octave','<',0),'ImplicitExpansion',...
ComputeNonCryptHash_f23('>=','R2016b','Octave','>',0),'bsxfun',ComputeNonCryptHash_f23('>=',...
'R2007a','Octave','>',0),'IntegerArithmetic',ComputeNonCryptHash_f23('>=','R2010b','Octave','>',...
0),'String',ComputeNonCryptHash_f23('>=','R2016b','Octave','<',0),'HTTPS_support',...
ComputeNonCryptHash_f23('>',0,'Octave','<',0),'json',ComputeNonCryptHash_f23('>=','R2016b',...
'Octave','>=',7),'strtrim',ComputeNonCryptHash_f23('>=',7,'Octave','>=',0),'accumarray',...
ComputeNonCryptHash_f23('>=',7,'Octave','>=',0));v002.CharIsUTF8=ComputeNonCryptHash_f09;end,...
v000=v002.(v001);end
function v000=ComputeNonCryptHash_f01(v001),persistent v002,if isempty(v002),v002=...
upper(dec2hex(0:(-1+2^16),4));end,v001=double(v001)+1;v000=v002(v001,:);end
function v000=ComputeNonCryptHash_f02(v000),persistent v001,if isempty(v001),v001=...
ComputeNonCryptHash_f00('ImplicitExpansion');end,if mod(numel(v000),16),...
v000(16*ceil(numel(v000)/16))=0;end,v002=uint16(2.^(15:-1:0))';v000=uint16(reshape(v000,16,[]));
if v001,v000=v000.*v002;else,v000=double(v000).*repmat(double(v002),[1 size(v000,2)]);v000=...
uint16(v000);end,v000=uint16(sum(v000,1)).';end
function v000=ComputeNonCryptHash_f03(v000),v001=65537;v002=479001600;v000=...
uint16(mod(double(v000) * v002,v001));end
function v000=ComputeNonCryptHash_f04(v000,v001),if isa(v000,'uint16'),v002='uint16';v003=...
size(v000).';v000=reshape(v000,[],1);v000=[v000;uint16(v002.');uint16(mod(v003,2^16))];return,...
end,v000=ComputeNonCryptHash_f05({v000},v001);v000([end-1 end])=[];end
function v000=ComputeNonCryptHash_f05(v000,v001),v002=size(v000).';v000=v000(:);for v003=...
1:numel(v000),if numel(v000{v003})==0,v004=double(class(v000{v003})');v000{v003}=uint16([0;v004;
size(v000{v003})']);continue,end,switch class(v000{v003}),case{'double','single'},v000{v003}=...
ComputeNonCryptHash_f06(v000{v003});case'logical',v000{v003}=...
ComputeNonCryptHash_f20(v000{v003});case{'uint8','uint16','uint32','uint64','int8','int16',...
'int32','int64'},v000{v003}=ComputeNonCryptHash_f42(v000{v003},v001);case'char',v000{v003}=...
ComputeNonCryptHash_f48(v000{v003},v001);case'string',v000{v003}=...
ComputeNonCryptHash_f49(v000{v003},v001);case'cell',v000{v003}=...
ComputeNonCryptHash_f05(v000{v003},v001);case'struct',v000{v003}=...
ComputeNonCryptHash_f07(v000{v003},v001);case{'gpuArray','tall'},v000{v003}=...
ComputeNonCryptHash_f05({gather(v000{v003})},v001);otherwise,...
ComputeNonCryptHash_f15(v001.print_to,'HJW:cast_to_uint16_vector:nosupport',...
'Unsupported data type in nested variable'),end,end,v000=cell2mat(v000);v000=[v000;
uint16(mod(v002,2^16))];end
function v000=ComputeNonCryptHash_f06(v000),v001=size(v000).';v002=class(v000);v000=...
reshape(v000,size(v000,1),[]);[v003,v004]=ComputeNonCryptHash_f47(double(v000));v005=mod(v003,...
2^16);v003=v003-v005;v003=v003/2^16;v004=v004.';v006=mod(v003,2^16);v003=v003-v006;v003=...
v003/2^16;v006=v006.';v007=mod(v003,2^16);v003=v003-v007;v003=v003/2^16;v007=v007.';v008=...
mod(v003,2^16);v008=v008.';v000=[v008;v007;v006;v004];v000=uint16(v000(:));v000=[v000;
uint16(v002.');uint16(mod(v001,2^16))];end
function v000=ComputeNonCryptHash_f07(v000,v001),v002=size(v000).';v000=v000(:);v003=...
fieldnames(v000);v004=cell(2,numel(v003));for v005=1:numel(v003),v004{1,v005}=v003{v005};v004{2,...
v005}={v000.(v003{v005})};end,v000=ComputeNonCryptHash_f05(v004,v001);v000=[v000;
uint16(mod(v002,2^16))];end
function v000=ComputeNonCryptHash_f08(v001,v002),v003=isa(v001,'char');v001=int32(v001);if ...
nargin<2,if any(v001==13),v001=ComputeNonCryptHash_f44(v001,int32([13 10]),int32(-10));
v001(v001==13)=-10;end,v001(v001==10)=-10;else,for v004=1:numel(v002),v001=...
ComputeNonCryptHash_f44(v001,int32(v002{v004}),int32(-10));end,end,v005=[0 find(v001==-10) ...
numel(v001)+1];v000=cell(numel(v005)-1,1);for v004=1:numel(v000),v006=(v005(v004)+1);v007=...
(v005(v004+1)-1);v000{v004}=v001(v006:v007);end,if v003,for v004=1:numel(v000),v000{v004}=...
char(v000{v004});end,else,for v004=1:numel(v000),v000{v004}=uint32(v000{v004});end,end,end
function v000=ComputeNonCryptHash_f09,persistent v001,if isempty(v001),if ...
ComputeNonCryptHash_f23('<',0,'Octave','>',0),v002=struct('w',warning('off','all'));[v002.msg,...
v002.ID]=lastwarn;v001=~isequal(8364,double(char(8364)));warning(v002.w);lastwarn(v002.msg,...
v002.ID);else,v001=false;end,end,v000=v001;end
function[v000,v001,v002]=ComputeNonCryptHash_f10(varargin),v003=false;[v004,v002]=...
ComputeNonCryptHash_f12(varargin{:});if~isempty(v002),v003=true;end,v005=...
ComputeNonCryptHash_f14;varargin=v004;[v000,v001,v002,v006,v007]=ComputeNonCryptHash_f40(v005,...
varargin{:});if v006,return,end,if v003,return,end,if numel(v007)==0,v000=true;v002=[];return,...
end,for v008=1:numel(v007),if strcmp(v007{v008},'VersionFlag'),try v009=...
str2double(v001.VersionFlag(3:end));if isnan(v009)||round(v009)~=v009||v009>2,error('trigger');
end,catch,v002.identifier='HJW:ComputeNonCryptHash:InputIncorrect';v002.message=...
'VersionFlag input incorrect. Must be ''-v1'', ''-v2''.';return,end,elseif strcmp(v007{v008},...
'HashLength'),v010=v001.HashLength;if numel(v010)~=1||~isnumeric(v010)||mod(v010,16)~=...
0||v010<16,v002.identifier='HJW:ComputeNonCryptHash:InputIncorrect';v002.message=...
'HashLength input must be a multiple of 16.';return,end,end,end,v000=true;v002=[];end
function[v000,v001,v002]=ComputeNonCryptHash_f11(v003),v001=v003{1};if ismember(class(v001),...
{'char','string'}),if isa(v001,'char')&&numel(v001)>=1&&strcmp('-',v001(1)),v000=1;else,v000=0;
end,else,if isa(v001,'struct'),v000=0;else,v000=2;end,end,v002=v003;if v000~=0,v002(1)=[];end,...
end
function[v000,v001]=ComputeNonCryptHash_f12(varargin),v001=[];v000=varargin;v002=[false false];
for v003=1:nargin,[v004,v005,v000]=ComputeNonCryptHash_f11(v000);switch v004,case 0,break,case ...
1,v006=v005;v002(1)=true;case 2,v007=v005;v002(2)=true;case 3,v001.identifier=...
'HJW:ComputeNonCryptHash:InputIncorrect';v001.message='Unable to determine a valid syntax.';
return,end,end,if nargin==sum(v002),v008=struct;if v002(1),v008.VersionFlag=v006;end,if v002(2),...
v008.HashLength=v007;end,v000={v008};else,if isa(v000{1},'stuct'),v008=v000{1};if v002(1),...
v008.VersionFlag=v006;end,if v002(2),v008.HashLength=v007;end,v000{1}=v008;else,v009=cell(1,0);
if v002(1),v009=[v009 {'VersionFlag',v006}];end,if v002(2),v009=[v009 {'HashLength',v007}];end,...
v000=[v009 v000];end,end,end
function v000=ComputeNonCryptHash_f13(v000),v000.Version=str2double(v000.VersionFlag(3:end));
if~isfield(v000,'re_encode_char_on_Octave'),v000.re_encode_char=v000.Version>=2;end,...
if~isfield(v000,'string_to_cellstr'),v000.string_to_cellstr=v000.Version>=2;if~isfield(v000,...
'cast_int64_double'),v000.cast_int64_double=v000.Version==1;end,end,end
function v003=ComputeNonCryptHash_f14,persistent v000,if isempty(v000),v000=struct;
v000.HashLength=256;v000.VersionFlag='-v2';v000.SkipInputParse=false;v000.isSaltCall=false;
[v000.print_to,v001]=ComputeNonCryptHash_f28;for v002=1:numel(v001),v000.(v001{v002})=[];end,...
end,v003=v000;end
function ComputeNonCryptHash_f15(v001,varargin),persistent v000,if isempty(v000),v000=func2str(...
@ComputeNonCryptHash_f15);end,if isempty(v001),v001=struct;end,v001=...
ComputeNonCryptHash_f43(v001);[v002,v003,v004,v005,v006]=ComputeNonCryptHash_f41(varargin{:});
if v006,return,end,v007=v005;if v001.params.ShowTraceInMessage,v003=sprintf('%s\n%s',v003,v005);
end,v008=struct('identifier',v002,'message',v003,'stack',v004);if ...
v001.params.WipeTraceForBuiltin,v008.stack=v004('name','','file','','line',[]);end,if ...
v001.boolean.obj,v009=v003;while v009(end)==10,v009(end)='';end,if any(v009==10),v009=...
ComputeNonCryptHash_f08(['Error: ' v009]);else,v009=['Error: ' v009];end,for v010=...
reshape(v001.obj,1,[]),try set(v010,'String',v009);catch,end,end,end,if v001.boolean.fid,v011=...
datestr(now,31);for v012=reshape(v001.fid,1,[]),try fprintf(v012,'[%s] Error: %s\n%s',v011,v003,...
v005);catch,end,end,end,if v001.boolean.fcn,if ismember(v000,{v004.name}),...
error('prevent recursion'),end,v013=v008;v013.trace=v007;for v014=reshape(v001.fcn,1,[]),if ...
isfield(v014,'data'),try feval(v014.h,'error',v013,v014.data);catch,end,else,try feval(v014.h,...
'error',v013);catch,end,end,end,end,rethrow(v008),end
function[v000,v001]=ComputeNonCryptHash_f16(v002,v001),if nargin==0,v002=1;end,if nargin<2,v001=...
dbstack;end,v001(1:v002)=[];if~isfield(v001,'file'),for v003=1:numel(v001),v004=v001(v003).name;
if strcmp(v004(end),')'),v005=strfind(v004,'(');v006=v004((v005(end)+1):(end-1));v007=...
v004(1:(v005(end)-2));else,v007=v004;[v008,v006]=fileparts(v004);end,[v008,v001(v003).file]=...
fileparts(v007);v001(v003).name=v006;end,end,persistent v009,if isempty(v009),v009=...
ComputeNonCryptHash_f23('<',0,'Octave','>',0);end,if v009,for v003=1:numel(v001),[v008,...
v001(v003).file]=fileparts(v001(v003).file);end,end,v010=v001;v011='>';v000=cell(1,...
numel(v010)-1);for v003=1:numel(v010),[v012,v010(v003).file,v013]=fileparts(v010(v003).file);if ...
v003==numel(v010),v010(v003).file='';end,if strcmp(v010(v003).file,v010(v003).name),...
v010(v003).file='';end,if~isempty(v010(v003).file),v010(v003).file=[v010(v003).file '>'];end,...
v000{v003}=sprintf('%c In %s%s (line %d)\n',v011,v010(v003).file,v010(v003).name,...
v010(v003).line);v011=' ';end,v000=horzcat(v000{:});end
function v000=ComputeNonCryptHash_f17(v000),persistent v001,v002=size(v000);if ...
isempty(v001)||any(size(v001)<v002)||isempty(v001{v002(1),v002(2)}),[v003,v004]=...
meshgrid(1:size(v000,2),1:size(v000,1));v005=mod(v003+v004-2,size(v000,1))+1;v006=...
sub2ind(size(v000),v005,v003);if prod(v002)<=1000,v001{v002(1),v002(2)}=v006;end,else,v006=...
v001{v002(1),v002(2)};end,v000=v000(v006);end
function v000=ComputeNonCryptHash_f18(v000,v001),v002=16*numel(v000);v003=v001;v003.Version=1;
v003.HashLength=v002;v003.SkipInputParse=1;v003.isSaltCall=1;v004=ComputeNonCryptHash(v000,...
v003);v004=ComputeNonCryptHash_f19(v004);if v001.Version>1,v004=v004(end:-1:1);end,v000=...
mod(double(v000).*double(v004),1+2^16);v000=uint16(v000);end
function v000=ComputeNonCryptHash_f19(v000),v001=65537;v002=1919;v000=uint16(mod(double(v000) * ...
v002,v001));end
function v000=ComputeNonCryptHash_f20(v000),v001=size(v000).';v000=v000(:);persistent v002,if ...
isempty(v002),v002=ComputeNonCryptHash_f00('ImplicitExpansion');end,if mod(numel(v000),16),...
v000(16*ceil(numel(v000)/16))=0;end,v003=uint16(2.^(15:-1:0))';v000=uint16(reshape(v000,16,[]));
if v002,v000=v000.*v003;else,v000=double(v000).*repmat(double(v003),[1 size(v000,2)]);v000=...
uint16(v000);end,v000=uint16(sum(v000,1)).';v000=[v000;uint16(mod(v001,2^16))];end
function v000=ComputeNonCryptHash_f21(v000),persistent v001,if isempty(v001),v001=...
dec2bin(0:(-1+2^16))=='1';v001=v001.';end,v000=double(v000)+1;v000=v001(:,v000);end
function v000=ComputeNonCryptHash_f22(v001,v002),persistent v003,if isempty(v003),v003=...
double(ComputeNonCryptHash_f00('ImplicitExpansion')) + ...
double(ComputeNonCryptHash_f00('bsxfun'));end,if v003==2,v000=v001+v002;elseif v003==1,v000=...
bsxfun(@plus,v001,v002);else,v004=ones(1,max(ndims(v001),ndims(v002)));v005=v004;
v004(1:ndims(v001))=size(v001);v005(1:ndims(v002))=size(v002);v006=v004~=1&v005~=1;
if~isequal(v004(v006),v005(v006)),error('HJW:bsxfun_plus:arrayDimensionsMustMatch',...
'Non-singleton dimensions of the two input arrays must match each other.'),end,if min([v004 ...
v005])==0,v004(v004==0)=inf;v005(v005==0)=inf;v007=max(v004,v005);v007(isinf(v007))=0;v000=...
feval(str2func(class(v001)),zeros(v007));return,end,v001=repmat(v001,max(1,v005./v004));v002=...
repmat(v002,max(1,v004./v005));v000=v001+v002;end,end
function v000=ComputeNonCryptHash_f23(v001,v002,v003,v004,v005),if nargin<2||nargout>1,...
error('incorrect number of input/output arguments'),end,persistent v006 v007 v008,if ...
isempty(v006),v008=exist('OCTAVE_VERSION','builtin');v006=[100,1] * sscanf(version,'%d.%d',2);
v007={'R13' 605;'R13SP1' 605;'R13SP2' 605;'R14' 700;'R14SP1' 700;'R14SP2' 700;'R14SP3' 701;
'R2006a' 702;'R2006b' 703;'R2007a' 704;'R2007b' 705;'R2008a' 706;'R2008b' 707;'R2009a' 708;
'R2009b' 709;'R2010a' 710;'R2010b' 711;'R2011a' 712;'R2011b' 713;'R2012a' 714;'R2012b' 800;
'R2013a' 801;'R2013b' 802;'R2014a' 803;'R2014b' 804;'R2015a' 805;'R2015b' 806;'R2016a' 900;
'R2016b' 901;'R2017a' 902;'R2017b' 903;'R2018a' 904;'R2018b' 905;'R2019a' 906;'R2019b' 907;
'R2020a' 908;'R2020b' 909;'R2021a' 910;'R2021b' 911;'R2022a' 912;'R2022b' 913;'R2023a' 914;
'R2023b' 2302};end,if v008,if nargin==2,warning('HJW:ifversion:NoOctaveTest',...
['No version test for Octave was provided.',char(10),...
'This function might return an unexpected outcome.']),if isnumeric(v002),v009=...
0.1*v002+0.9*ComputeNonCryptHash_f27(v002);v009=round(100*v009);else,v010=ismember(v007(:,1),...
v002);if sum(v010)~=1,warning('HJW:ifversion:NotInDict',...
'The requested version is not in the hard-coded list.'),v000=NaN;return,else,v009=v007{v010,2};
end,end,elseif nargin==4,[v001,v009]=deal(v003,v004);v009=...
0.1*v009+0.9*ComputeNonCryptHash_f27(v009);v009=round(100*v009);else,[v001,v009]=deal(v004,...
v005);v009=0.1*v009+0.9*ComputeNonCryptHash_f27(v009);v009=round(100*v009);end,else,if ...
isnumeric(v002),v009=ComputeNonCryptHash_f27(v002*100);if mod(v009,10)==0,v009=...
ComputeNonCryptHash_f27(v002)*100+mod(v002,1)*10;end,else,v010=ismember(v007(:,1),v002);if ...
sum(v010)~=1,warning('HJW:ifversion:NotInDict',...
'The requested version is not in the hard-coded list.'),v000=NaN;return,else,v009=v007{v010,2};
end,end,end,switch v001,case'==',v000=v006==v009;case'<',v000=v006 < v009;case'<=',v000=v006 <=...
v009;case'>',v000=v006 > v009;case'>=',v000=v006 >=v009;end,end
function[v000,v001]=ComputeNonCryptHash_f24(v002,varargin),switch numel(v002),case 0,...
error('parse_NameValue:MixedOrBadSyntax',...
'Optional inputs must be entered as Name,Value pairs or as a scalar struct.'),case 1,otherwise,...
v002=v002(1);end,v000=v002;v001={};if nargin==1,return,end,try v003=numel(varargin)==...
1&&isa(varargin{1},'struct');v004=mod(numel(varargin),2)==0&&all(cellfun('isclass',...
varargin(1:2:end),'char')|cellfun('isclass',varargin(1:2:end),'string'));if~(v003||v004),...
error('trigger'),end,if nargin==2,v005=fieldnames(varargin{1});v006=struct2cell(varargin{1});
else,v005=cellstr(varargin(1:2:end));v006=varargin(2:2:end);end,if~iscellstr(v005),...
error('trigger');end,catch,error('parse_NameValue:MixedOrBadSyntax',...
'Optional inputs must be entered as Name,Value pairs or as a scalar struct.'),end,v007=...
fieldnames(v002);v008=cell(1,4);v009{1}=v007;v009{2}=lower(v009{1});v009{3}=strrep(v009{2},'_',...
'');v009{4}=strrep(v009{3},'-','');v005=strrep(v005,' ','_');v001=false(size(v007));for v010=...
1:numel(v005),v011=v005{v010};[v012,v008{1}]=ComputeNonCryptHash_f25(v008{1},v009{1},v011);if ...
numel(v012)~=1,v011=lower(v011);[v012,v008{2}]=ComputeNonCryptHash_f25(v008{2},v009{2},v011);
end,if numel(v012)~=1,v011=strrep(v011,'_','');[v012,v008{3}]=ComputeNonCryptHash_f25(v008{3},...
v009{3},v011);end,if numel(v012)~=1,v011=strrep(v011,'-','');[v012,v008{4}]=...
ComputeNonCryptHash_f25(v008{4},v009{4},v011);end,if numel(v012)~=1,...
error('parse_NameValue:NonUniqueMatch',v005{v010}),end,v000.(v007{v012})=v006{v010};v001(v012)=...
true;end,v001=v007(v001);end
function[v000,v001]=ComputeNonCryptHash_f25(v001,v002,v003),v000=find(ismember(v002,v003));if ...
numel(v000)==1,return,end,if isempty(v001),v001=ComputeNonCryptHash_f26(v002);end,v004=v001(:,...
1:min(end,numel(v003)));if size(v004,2)<numel(v003),v004=[v004 repmat(' ',size(v004,1),...
numel(v003)-size(v004,2))];end,v005=numel(v003)-sum(cumprod(double(v004==repmat(v003,size(v004,...
1),1)),2),2);v000=find(v005==0);end
function v000=ComputeNonCryptHash_f26(v000),v001=cellfun('prodofsize',v000);v002=max(v001);for ...
v003=find(v001<v002).',v000{v003}((end+1):v002)=' ';end,v000=vertcat(v000{:});end
function v000=ComputeNonCryptHash_f27(v000),v000=fix(v000+eps*1e3);end
function[v002,v003]=ComputeNonCryptHash_f28,persistent v000 v001,if isempty(v000),[v000,v001]=...
ComputeNonCryptHash_f29;end,v002=v000;v003=v001;end
function[v001,v004]=ComputeNonCryptHash_f29,v000=struct('ShowTraceInMessage',false,...
'WipeTraceForBuiltin',false);v001=struct('params',v000,'fid',[],'obj',[],'fcn',struct('h',{},...
'data',{}),'boolean',struct('con',[],'fid',false,'obj',false,'fcn',false,'IsValidated',false));
v002=fieldnames(v000);for v003=1:numel(v002),v002{v003}=['option_' v002{v003}];end,v004=...
[{'params'};v002;{'con';'fid';'obj';'fcn'}];for v003=1:numel(v004),v004{v003}=['print_to_' ...
v004{v003}];end,v004=sort(v004);end
function v000=ComputeNonCryptHash_f30(v001),persistent v002 v003 v004,if isempty(v003),[v002,...
v003]=ComputeNonCryptHash_f28;v005='print_to_option_';for v006=numel(v003):-1:1,if~strcmp(v005,...
v003{v006}(1:min(end,numel(v005)))),v003(v006)=[];end,end,v004=strrep(v003,v005,'');end,v000=...
v002;if isfield(v001,'print_to_params'),v000.params=v001.print_to_params;else,for v006=...
1:numel(v003),v007=v003{v006};if isfield(v001,v003{v006}),v008=v004{v006};v000.params.(v008)=...
v001.(v007);end,end,end,if isfield(v001,'print_to_fid'),v000.fid=v001.print_to_fid;end,if ...
isfield(v001,'print_to_obj'),v000.obj=v001.print_to_obj;end,if isfield(v001,'print_to_fcn'),...
v000.fcn=v001.print_to_fcn;end,if isfield(v001,'print_to_con'),v000.boolean.con=...
v001.print_to_con;end,v000.boolean.IsValidated=false;end
function[v000,v001,v002]=ComputeNonCryptHash_f31(v002),v003=nargout>=3;v001=struct('identifier',...
'','message','');v000=true;if nargout>=3,v003=true;end,[v004,v005]=...
ComputeNonCryptHash_f46(v002.boolean.IsValidated);if v004&&v005,return,end,[v004,...
v002.boolean.con]=ComputeNonCryptHash_f46(v002.boolean.con);if~v004&&~isempty(v002.boolean.con),...
v001.message=['Invalid print_to_con parameter:',char(10),...
'should be a scalar logical or empty double.'];v001.identifier='HJW:print_to:ValidationFailed';
v000=false;if~v003,return,end,end,[v006,v002.fid]=ComputeNonCryptHash_f32(v002.fid);if v006,...
v001.message=['Invalid print_to_fid parameter:',char(10),...
'should be a valid file identifier or 1.'];v001.identifier='HJW:print_to:ValidationFailed';v000=...
false;if~v003,return,end,end,v002.boolean.fid=~isempty(v002.fid);[v006,v002.obj]=...
ComputeNonCryptHash_f33(v002.obj);if v006,v001.message=['Invalid print_to_obj parameter:',...
char(10),'should be a handle to an object with a writeable String property.'];v001.identifier=...
'HJW:print_to:ValidationFailed';v000=false;if~v003,return,end,end,v002.boolean.obj=...
~isempty(v002.obj);[v006,v002.fcn]=ComputeNonCryptHash_f34(v002.fcn);if v006,v001.message=...
['Invalid print_to_fcn parameter:',char(10),...
'should be a struct with the h field containing a function handle,',char(10),...
'anonymous function or inline function.'];v001.identifier='HJW:print_to:ValidationFailed';v000=...
false;if~v003,return,end,end,v002.boolean.fcn=~isempty(v002.fcn);[v006,v002.params]=...
ComputeNonCryptHash_f39(v002.params);if v006,v001.message=...
['Invalid print_to____params parameter:',char(10),...
'should be a scalar struct uniquely matching parameter names.'];v001.identifier=...
'HJW:print_to:ValidationFailed';v000=false;if~v003,return,end,end,if isempty(v002.boolean.con),...
v002.boolean.con=~any([v002.boolean.fid v002.boolean.obj v002.boolean.fcn]);end,if~v000,...
v002.boolean.con=true;end,v002.boolean.IsValidated=true;end
function[v000,v001]=ComputeNonCryptHash_f32(v001),v000=false;for v002=numel(v001):-1:1,try v003=...
ftell(v001(v002));catch,v003=-1;end,if v001(v002)~=1&&v003==-1,v000=true;v001(v002)=[];end,end,...
end
function[v000,v001]=ComputeNonCryptHash_f33(v001),v000=false;for v002=numel(v001):-1:1,try v003=...
get(v001(v002),'String');set(v001(v002),'String','');set(v001(v002),'String',v003);catch,v000=...
true;v001(v002)=[];end,end,end
function[v000,v001]=ComputeNonCryptHash_f34(v001),v000=false;for v002=numel(v001):-1:1,...
if~isa(v001,'struct')||~isfield(v001,'h')||~ismember(class(v001(v002).h),{'function_handle',...
'inline'})||numel(v001(v002).h)~=1,v000=true;v001(v002)=[];end,end,end
function v000=ComputeNonCryptHash_f35(v001),if numel(v001)>1,...
error('this should only be used for single characters'),end,if v001<128,v000=v001;return,end,...
persistent v002,if isempty(v002),v002=struct;v002.limits.lower=hex2dec({'0000','0080','0800',...
'10000'});v002.limits.upper=hex2dec({'007F','07FF','FFFF','10FFFF'});v002.scheme{2}=...
'110xxxxx10xxxxxx';v002.scheme{2}=reshape(v002.scheme{2}.',8,2);v002.scheme{3}=...
'1110xxxx10xxxxxx10xxxxxx';v002.scheme{3}=reshape(v002.scheme{3}.',8,3);v002.scheme{4}=...
'11110xxx10xxxxxx10xxxxxx10xxxxxx';v002.scheme{4}=reshape(v002.scheme{4}.',8,4);for v003=2:4,...
v002.scheme_pos{v003}=find(v002.scheme{v003}=='x');v002.bits(v003)=numel(v002.scheme_pos{v003});
end,end,v004=find(v002.limits.lower<=v001&v001<=v002.limits.upper);v000=v002.scheme{v004};v005=...
v002.scheme_pos{v004};v003=dec2bin(double(v001),v002.bits(v004));v000(v005)=v003;v000=...
bin2dec(v000.').';end
function[v000,v001,v002]=ComputeNonCryptHash_f36(v003,v004),if nargin<2,v004=[];end,v005=...
nargout==1;v003=uint32(reshape(v003,1,[]));[v002,v006,v007]=ComputeNonCryptHash_f38(v003,v005);
if strcmp(v006,'success'),v001=true;v000=v002;elseif strcmp(v006,'error'),v001=false;if v005,...
ComputeNonCryptHash_f15(v004,v007),end,v000=v003;end,end
function v000=ComputeNonCryptHash_f37(v001),if v001<65536,v000=v001;return,end,v002=...
double(v001)-65536;v002=dec2bin(v002,20);v000=bin2dec(['110110' v002(1:10);'110111' ...
v002(11:20)]).';end
function[v000,v001,v002]=ComputeNonCryptHash_f38(v000,v003),v001='success';v002=...
struct('identifier','HJW:UTF8_to_unicode:notUTF8','message','Input is not UTF-8.');persistent ...
v004,if isempty(v004),v004=ComputeNonCryptHash_f23('<',0,'Octave','>',0);end,if any(v000>255),...
v001='error';if v003,return,end,elseif all(v000<128),return,end,for v005=4:-1:2,v006=...
bin2dec([repmat('1',1,v005) repmat('0',1,8-v005)]);v007=v000>=v006&v000<256;if any(v007),v007=...
find(v007);v007=v007(:).';if numel(v000)<(max(v007)+v005-1),v001='error';if v003,return,end,...
v007((v007+v005-1)>numel(v000))=[];end,if~isempty(v007),v008=ComputeNonCryptHash_f22(v007,...
(0:(v005-1)).');v008=v008.';v007=v000(v008);end,else,v007=[];end,v009=[repmat('1',1,v005-1) ...
repmat('10',1,v005)];v010=unique([1:(v005+1) 1:8:(8*v005) 2:8:(8*v005)]);if numel(v007)>0,v007=...
unique(v007,'rows');v011=mat2cell(v007,ones(size(v007,1),1),v005);for v012=1:numel(v011),v013=...
dec2bin(double(v011{v012}))';if~strcmp(v009,v013(v010)),v001='error';if v003,return,end,...
continue,end,v013(v010)='';if~v004,v014=uint32(bin2dec(v013));else,v014=uint32(bin2dec(v013.'));
end,v000=ComputeNonCryptHash_f44(v000,v011{v012},v014);end,end,end,end
function[v000,v001]=ComputeNonCryptHash_f39(v001),v000=false;persistent v002,if isempty(v002),...
v002=ComputeNonCryptHash_f28;v002=v002.params;end,if isempty(v001),v001=struct;end,if~isa(v001,...
'struct'),v000=true;v001=v002;return,end,while true,try v003=[];[v001,v004]=...
ComputeNonCryptHash_f24(v002,v001);break,catch v003;if isempty(v003),v003=lasterror;end,v000=...
true;v001=rmfield(v001,v003.message);end,end,for v005=1:numel(v004),v006=v004{v005};switch v006,...
case'ShowTraceInMessage',[v007,v001.(v006)]=ComputeNonCryptHash_f46(v001.(v006));if~v007,v000=...
true;v001.(v006)=v002.(v006);end,case'WipeTraceForBuiltin',[v007,v001.(v006)]=...
ComputeNonCryptHash_f46(v001.(v006));if~v007,v000=true;v001.(v006)=v002.(v006);end,end,end,end
function[v000,v001,v002,v003,v004]=ComputeNonCryptHash_f40(v005,varargin),v000=false;v003=false;
v002=struct('identifier','','message','');v004=cell(0);try v006=[];[v001,v004]=...
ComputeNonCryptHash_f24(v005,varargin{:});catch v006;if isempty(v006),v006=lasterror;end,v002=...
v006;v003=true;end,if v003,if isa(varargin{1},'struct'),v001=varargin{1};else,try v001=...
struct(varargin{:});catch,v001=struct;end,end,if isfield(v001,'print_to'),v007=v001.print_to;
else,v007=ComputeNonCryptHash_f30(v001);end,else,if ismember('print_to',v004),v007=...
v001.print_to;else,v007=ComputeNonCryptHash_f30(v001);end,end,[v008,v009,v001.print_to]=...
ComputeNonCryptHash_f31(v007);if~v008,v002=v009;v003=true;end,end
function[v000,v001,v002,v003,v004]=ComputeNonCryptHash_f41(varargin),v004=false;if nargin==1,if ...
isa(varargin{1},'struct')||isa(varargin{1},'MException'),v005=varargin{1};if numel(v005)~=1,...
v004=true;[v000,v001,v002,v003]=deal('');return,end,try v002=v005.stack;v003=...
ComputeNonCryptHash_f16(0,v002);catch,[v003,v002]=ComputeNonCryptHash_f16(3);end,v000=...
v005.identifier;v001=v005.message;v006='Error using ==> ';if strcmp(v001(1:min(end,...
numel(v006))),v006),v007=min(find(ismember(double(v001),[10 13])));if any(double(v001(v007+1))==...
[10 13]),v007=v007-1;end,v001(1:v007)='';end,v006=...
'Error using <a href="matlab:matlab.internal.language.introspective.errorDocCallbac';if ...
isa(v005,'struct')&&strcmp(v006,v001(1:min(end,numel(v006)))),v001(1:min(find(v001==10)))='';
end,else,[v003,v002]=ComputeNonCryptHash_f16(3);[v000,v001]=deal('',varargin{1});end,else,[v003,...
v002]=ComputeNonCryptHash_f16(3);if~isempty(strfind(varargin{1},'%')),v000='';v008=...
varargin(2:end);v001=sprintf(varargin{1},v008{:});else,v000=varargin{1};v001=varargin{2};if ...
nargin>2,v008=varargin(3:end);v001=sprintf(v001,v008{:});end,end,end,end
function v000=ComputeNonCryptHash_f42(v000,v001),v002=size(v000).';v000=v000(:);persistent v003,...
if isempty(v003),v003=ComputeNonCryptHash_f00('IntegerArithmetic');end,v004=class(v000);v005=...
~v001.cast_int64_double&&v003&&v004(end)=='4';if~v005,if any(abs(double(v000(:)))>2^52),...
ComputeNonCryptHash_f50(v001,'HJW:ComputeNonCryptHash:int64rounding',...
['int64 and uint64 will be rounded pre-R2010b, resulting in rounding.',char(10),...
'This will result in a hash that is different from newer releases.']),end,end,if v005,if ...
v004(1)~='u',v006=v000>0;v007=-int64(-inf);v008=uint64(v000+v007+1);v008(v006)=...
uint64(v000(v006))+uint64(v007)+1;v000=v008;end,elseif v004(1)~='u',switch v004,case'int8',v000=...
double(v000)-double(int8(-inf));case'int16',v000=double(v000)-double(int16(-inf));case'int32',...
v000=double(v000)-double(int32(-inf));case'int64',v000=double(v000)-double(int64(-inf));end,...
else,v000=double(v000);end,switch v004(end),case'8',if mod(numel(v000),2),v008=...
zeros((numel(v000)+1)/2,2);v008(1:(end-1))=v000;v000=v008;end,v000=reshape(v000,[],2);v000=...
v000(:,1)*255+v000(:,2);v000=uint16(v000);case'6',v000=uint16(v000);case'2',v009=...
floor(v000/2^16);v009=v009.';v010=mod(v000,2^16);v010=v010.';v000=[v009;v010];v000=...
uint16(v000(:));case'4',v011=v000;v012=mod(v011,2^16);v011=v011-v012;v011=v011/2^16;v012=v012.';
v013=mod(v011,2^16);v011=v011-v013;v011=v011/2^16;v013=v013.';v010=mod(v011,2^16);v011=...
v011-v010;v011=v011/2^16;v010=v010.';v009=mod(v011,2^16);v009=v009.';v000=[v009;v010;v013;v012];
v000=uint16(v000(:));end,v000=[v000;uint16(v004.');uint16(mod(v002,2^16))];end
function v000=ComputeNonCryptHash_f43(v000),if isfield(v000,'boolean')&&isfield(v000.boolean,...
'IsValidated')&&v000.boolean.IsValidated,return,end,try v001=...
ComputeNonCryptHash_f24(ComputeNonCryptHash_f28,v000);v001.boolean.IsValidated=false;catch,v001=...
ComputeNonCryptHash_f30(v000);end,[v002,v002,v000]=ComputeNonCryptHash_f31(v001);end
function v000=ComputeNonCryptHash_f44(v001,v002,v003),v001=reshape(v001,1,[]);v000=v001;if ...
numel(v002)==0||numel(v002)>numel(v001),return,end,v004=true(size(v001));
v004((end-numel(v002)+2):end)=false;for v005=1:numel(v002),v006=v001==v002(v005);v006=...
circshift(v006,[0 1-v005]);v006(1:(v005-1))=v004(1:(v005-1));v004=v004&v006;if~any(v004),return,...
end,end,if numel(v003)==0,v000(v004)=[];return,end,if numel(v002)>1,v007=...
ComputeNonCryptHash_f22(find(v004),reshape(1:(numel(v002)-1),[],1));else,v007=find(v004);end,...
v007=reshape(v007,1,[]);v008=repmat(' ',1,numel(v001));v008(v007)='_';v008(v004)='*';v009=v008==...
' ';v008=regexprep(v008,'\*_*',['*' repmat('_',1,numel(v003)-1)]);v000(v008==' ')=v001(v009);
v010=strfind(v008,'*');v007=ComputeNonCryptHash_f22(v010,reshape(0:(numel(v003)-1),[],1));v007=...
reshape(v007,1,[]);v000(v007)=repmat(v003,1,numel(v010));v000((numel(v008)+1):end)=[];end
function v000=ComputeNonCryptHash_f45(v001,v002),persistent v003,if isempty(v003),v003=...
ComputeNonCryptHash_f23('<',0,'Octave','>',0);end,if nargin==1,v002=~ComputeNonCryptHash_f09;
end,if v002,if all(v001<65536),v000=uint16(v001);v000=reshape(v000,1,numel(v000));else,[v004,...
v005,v006]=unique(v001);v000=cell(1,numel(v001));for v007=1:numel(v004),v008=...
ComputeNonCryptHash_f37(v004(v007));v008=uint16(v008);v000(v006==v007)={v008};end,v000=...
cell2mat(v000);end,if~v003,v000=char(v000);end,else,if all(v001<128),v000=char(v001);v000=...
reshape(v000,1,numel(v000));else,[v004,v005,v006]=unique(v001);v000=cell(1,numel(v001));for ...
v007=1:numel(v004),v008=ComputeNonCryptHash_f35(v004(v007));v008=uint8(v008);v000(v006==v007)=...
{v008};end,v000=cell2mat(v000);v000=char(v000);end,end,end
function[v000,v001]=ComputeNonCryptHash_f46(v001),persistent v002,if isempty(v002),v002={true,...
false;1,0;'true','false';'1','0';'on','off';'enable','disable';'enabled','disabled'};end,if ...
isa(v001,'matlab.lang.OnOffSwitchState'),v000=true;v001=logical(v001);return,end,if isa(v001,...
'string'),if numel(v001)~=1,v000=false;return,else,v001=char(v001);end,end,if isa(v001,'char'),...
v001=lower(v001);end,for v003=1:size(v002,1),for v004=1:2,if isequal(v001,v002{v003,v004}),v000=...
true;v001=v002{1,v004};return,end,end,end,v000=false;end
function[v000,v001]=ComputeNonCryptHash_f47(v002),[v003,v004]=log2(v002);v005=...
-floor(sign(v002)/2-0.5);v006=v004+1022;v007=abs(v003)*2-1;v000=zeros(size(v002));v000=...
v000+(v005*2^63);v000=v000+(v006*2^52);v000=v000+(v007*2^52);v001=mod(v007*2^52,2^16);v008=...
isinf(v002);v000(v002==0)=0;v000(isnan(v002))=18444492273895866368;v000(v008&v002>0)=...
9218868437227405312;v000(v008&v002<0)=18442240474082181120;v001(v002==0)=0;v001(isnan(v002))=0;
v001(v008)=0;end
function v000=ComputeNonCryptHash_f48(v000,v001),persistent v002,if isempty(v002),v002=...
ComputeNonCryptHash_f23('<',0,'Octave','>',0);end,if v002&&v001.re_encode_char,v003=size(v000,...
1)==numel(v000);if v003,v000=v000.';end,v000=cellstr(v000);for v004=1:numel(v000),v000{v004}=...
ComputeNonCryptHash_f45(ComputeNonCryptHash_f36(v000{v004},v001.print_to),true);end,v005=...
cellfun('length',v000);v006=max(v005);for v004=find(v005<v006),...
v000{v004}((numel(v000{v004})+1):v006)=uint16(' ');end,v000=cell2mat(v000);if v003,v000=v000.';
end,end,v007=size(v000).';v000=v000(:);v000=uint16(v000);v000=[v000;uint16(mod(v007,2^16))];end
function v000=ComputeNonCryptHash_f49(v000,v001),if v001.string_to_cellstr,v000=cellstr(v000);
v000=ComputeNonCryptHash_f05(v000,v001);else,v000=char(v000);v000=ComputeNonCryptHash_f48(v000,...
v001);end,end
function ComputeNonCryptHash_f50(v001,varargin),persistent v000,if isempty(v000),v000=func2str(...
@ComputeNonCryptHash_f50);end,if isempty(v001),v001=struct;end,v001=...
ComputeNonCryptHash_f43(v001);[v002,v003,v004,v005,v006]=ComputeNonCryptHash_f41(varargin{:});
v007=v005;if v006,return,end,v008=warning;if any(ismember({v008(ismember({v008.identifier},...
{v002,'all'})).state},'off')),return,end,v009=warning('query','backtrace');if strcmp(v009.state,...
'off'),v005='';end,if v001.params.ShowTraceInMessage&&~isempty(v005),v003=sprintf('%s\n%s',v003,...
v005);end,if v001.params.WipeTraceForBuiltin&&strcmp(v009.state,'on'),warning('off',...
'backtrace'),end,if v001.boolean.con,v010=warning('query','verbose');if strcmp(v010.state,'on'),...
warning('off','verbose'),end,if~isempty(v002),warning(v002,'%s',v003),else,warning(v003),end,if ...
strcmp(v010.state,'on'),warning('on','verbose'),end,else,if~isempty(v002),lastwarn(v003,v002);
else,lastwarn(v003),end,end,if v001.params.WipeTraceForBuiltin&&strcmp(v009.state,'on'),...
warning('on','backtrace'),end,if v001.boolean.obj,v011=v003;while v011(end)==10,v011(end)=[];
end,if any(v011==10),v011=ComputeNonCryptHash_f08(['Warning: ' v011]);else,v011=['Warning: ' ...
v011];end,set(v001.obj,'String',v011),for v012=reshape(v001.obj,1,[]),try set(v012,'String',...
v011);catch,end,end,end,if v001.boolean.fid,v013=datestr(now,31);for v014=reshape(v001.fid,1,...
[]),try fprintf(v014,'[%s] Warning: %s\n%s',v013,v003,v005);catch,end,end,end,if ...
v001.boolean.fcn,if ismember(v000,{v004.name}),error('prevent recursion'),end,v015=...
struct('identifier',v002,'message',v003,'stack',v004,'trace',v007);for v016=reshape(v001.fcn,1,...
[]),if isfield(v016,'data'),try feval(v016.h,'warning',v015,v016.data);catch,end,else,try ...
feval(v016.h,'warning',v015);catch,end,end,end,end,end
function [out,out_struct]=ETA_disp(N_total,n,then,per_it_display,scale_estimate)
%Display the estimated time of completion of a looping process
%
% To keep this function fast no input checking is done.
% The time remaining is capped at 10^10 seconds.
% The output for tic was introduced in R2008b, so tic/toc can't be nested in all releases, while
% this implementation can be nested in any release.
%
% Syntax:
%   ETA_disp(N_total,n,then)
%   ETA_disp(N_total,n,then,per_it_display)
%   ETA_disp(N_total,n,then,per_it_display,scale_estimate)
%   msg = ETA_disp(___)
%   [msg,strct] = ETA_disp(___)
%
% Input/output arguments:
% msg:
%   If an output argument is provided the message is not printed to the command window, but is
%   instead returned as a cell array.
% strct:
%   The second output argument is a struct with several fields containing the components of the
%   message. The included variables are the percentage done ('p_done'), the text with the elapsed
%   time ('elapsed_str'), the estimated time of completion ('ETA'), the estimated date of
%   completion ('ETA_date', empty if the estimated time left is less than a day), the number of
%   minutes per iteration ('t_min'), the number of seconds per iteration ('t_sec'), and the number
%   of iterations per second ('it_per_sec').
% N_total:
%   The total number of iterations.
% n:
%   The current count of iterations (this will be adjusted up to eps if 0).
% then:
%   This should be the value the now function returned before the loop began.
% per_it_display:
%   (optional, default is 0) 0 for automatic, -1 to display time per iteration on the last line, or
%   1 to print iterations per seconds on the last line.
% scale_estimate:
%   the time remaining is multiplied by this factor (this doesn't change the rate calculated over
%   the processed iterations). This allows skewing the estimate in cases where the earlier
%   iterations are expected to be faster.
%
% Examples:
%
%   N = 10;then = now; %#ok<TNOW1>
%   for n=1:N
%       pause((1+rand)*2/N)
%       ETA_disp(N,n,then)
%   end
%
%   N = 10^6;then = now; %#ok<TNOW1>
%   for n=1:N
%       pause((1+rand)*2/N)
%       if mod(n,10^4)==0 % Avoid spending too much time printing the ETA.
%           ETA_disp(N,n,then,1) % Print iterations/sec instead of sec/iteration.
%       end
%   end
%
%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%
%|                                                                         |%
%|  Version: 2.0.0                                                         |%
%|  Date:    2023-11-03                                                    |%
%|  Author:  H.J. Wisselink                                                |%
%|  Licence: CC by-nc-sa 4.0 ( creativecommons.org/licenses/by-nc-sa/4.0 ) |%
%|  Email = 'h_j_wisselink*alumnus_utwente_nl';                            |%
%|  Real_email = regexprep(Email,{'*','_'},{'@','.'})                      |%
%|                                                                         |%
%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%/%
%
% Tested on several versions of Matlab (ML 6.5 and onward) and Octave (4.4.1 and onward), and on
% multiple operating systems (Windows/Ubuntu/MacOS). You can see the full test matrix below.
% Compatibility considerations:
% - This is expected to work on all releases.

% Before doing any processing, make sure the time is captured to avoid any offsets caused by this
% function itself.
t = (now-then)*(24*60*60); %#ok<TNOW1> This is equivalent to t=toc(h_tic);

persistent legacy
if isempty(legacy)
    % The addtodate function was introduced in ML7.0 (R14), but the 'second' option was only
    % implemented later, in R2008b.
    checkpoint('ETA_disp','ifversion')
    legacy.addtodate = ifversion('<','R2008b','Octave','<',4);
end
if nargin<4 || numel(per_it_display)~=1,per_it_display = 0;end
if nargin<5 || numel(scale_estimate)~=1,scale_estimate = 1;end
n = max(eps,n); % Ensure n is non-zero, which would cause problems later.
t_min_total = floor(t/60);t_sec_total=round(t-60*t_min_total); % Calculate time elapsed.
f = n/N_total;t_r = (t-f*t)/f; % Calculation fraction done and time remaining.
if nargin>=5,t_r = t_r*scale_estimate;end % Scale the remainder estimate.
t_r = min(10^10,round(t_r)); % Round and cap to 10^10 seconds.
if legacy.addtodate
    ETA = datestr(now+(t_r/(24*60*60)),'HH:MM:SS'); %#ok<TNOW1,DATST>
else
    ETA = datestr(addtodate(now,t_r,'second'),'HH:MM:SS'); %#ok<DATST,DATOD,TNOW1>
end
days_left = floor(t_r/(24*60*60));
if days_left>0
    ETA_date = datestr(now+days_left,26); %#ok<TNOW1,DATST>
    ETA_ = sprintf('%s (on %s)',ETA,ETA_date);
else
    ETA_date = '';
    ETA_ = ETA;
end
t_per_it = t/n; % This is in seconds per iteration.
t_min = floor(t_per_it/60);t_sec=t_per_it-60*t_min;
if abs(per_it_display)~=1 % Revert to dynamic if the input is invalid.
    if t_per_it>0.5
        per_it_display = -1; % Display time per iteration.
    else
        per_it_display =  1; % Display iterations per second.
    end
end
if per_it_display==-1
    per_it_display = sprintf('%02d:%05.2f per iteration',t_min,t_sec);
else
    per_it_display = sprintf('%.1f iterations per second',1/t_per_it);
end

% Determine time elapsed str (skipping days/hours if 0).
if t_min_total<60
    elapsed_str = sprintf('%02d:%02d',t_min_total,t_sec_total);
else
    t_hour_total = floor(t_min_total/60);
    t_min_total = t_min_total-60*t_hour_total;
    if t_hour_total<24
        elapsed_str = sprintf('%02d:%02d:%02d',t_hour_total,t_min_total,t_sec_total);
    else
        t_day_total = floor(t_hour_total/24);
        t_hour_total = t_hour_total-24*t_day_total;
        elapsed_str = sprintf('%d/%02d:%02d:%02d',t_day_total,t_hour_total,t_min_total,t_sec_total);
    end
end

out_    = cell(1,3);
out_{1} = sprintf('%05.1f%% done after a total time of %s.', 100*n/N_total,elapsed_str);
out_{2} = sprintf('estimated time of completion: %s',        ETA_);
out_{3} = sprintf('(%s, %d iterations left)',                per_it_display,N_total-n);
if nargout==0
    clc
    fprintf('%s\n',out_{:});
end
if nargout>=1,out = out_;end
if nargout==2
    out_struct = struct(...
        'p_done',sprintf('%05.1f%%',100*n/N_total),...
        'elapsed_str',elapsed_str,...
        'ETA',ETA,...
        'ETA_date',ETA_date,...
        't_min',t_min,...
        't_sec',t_sec,...
        'it_per_sec',1/t_per_it);
end
end
function [str,stack]=get_trace(skip_layers,stack)
if nargin==0,skip_layers = 1;end
if nargin<2, stack = dbstack;end
stack(1:skip_layers) = [];

% Parse the ML6.5 style of dbstack (the name field includes full file location).
if ~isfield(stack,'file')
    for n=1:numel(stack)
        tmp = stack(n).name;
        if strcmp(tmp(end),')')
            % Internal function.
            ind = strfind(tmp,'(');
            name = tmp( (ind(end)+1):(end-1) );
            file = tmp(1:(ind(end)-2));
        else
            file = tmp;
            [ignore,name] = fileparts(tmp); %#ok<ASGLU>
        end
        [ignore,stack(n).file] = fileparts(file); %#ok<ASGLU>
        stack(n).name = name;
    end
end

% Parse Octave style of dbstack (the file field includes full file location).
checkpoint('get_trace','ifversion')
persistent isOctave,if isempty(isOctave),isOctave=ifversion('<',0,'Octave','>',0);end
if isOctave
    for n=1:numel(stack)
        [ignore,stack(n).file] = fileparts(stack(n).file); %#ok<ASGLU>
    end
end

% Create the char array with a (potentially) modified stack.
s = stack;
c1 = '>';
str = cell(1,numel(s)-1);
for n=1:numel(s)
    [ignore_path,s(n).file,ignore_ext] = fileparts(s(n).file); %#ok<ASGLU>
    if n==numel(s),s(n).file = '';end
    if strcmp(s(n).file,s(n).name),s(n).file = '';end
    if ~isempty(s(n).file),s(n).file = [s(n).file '>'];end
    str{n} = sprintf('%c In %s%s (line %d)\n',c1,s(n).file,s(n).name,s(n).line);
    c1 = ' ';
end
str = horzcat(str{:});
end
function tf=hasFeature(feature)
% Provide a single point to encode whether specific features are available.
persistent FeatureList
if isempty(FeatureList)
    checkpoint('hasFeature','ifversion')
    FeatureList = struct(...
        'HG2'              ,ifversion('>=','R2014b','Octave','<' ,0),...
        'ImplicitExpansion',ifversion('>=','R2016b','Octave','>' ,0),...
        'bsxfun'           ,ifversion('>=','R2007a','Octave','>' ,0),...
        'IntegerArithmetic',ifversion('>=','R2010b','Octave','>' ,0),...
        'String'           ,ifversion('>=','R2016b','Octave','<' ,0),...
        'HTTPS_support'    ,ifversion('>' ,0       ,'Octave','<' ,0),...
        'json'             ,ifversion('>=','R2016b','Octave','>=',7),...
        'strtrim'          ,ifversion('>=',7       ,'Octave','>=',0),...
        'accumarray'       ,ifversion('>=',7       ,'Octave','>=',0));
    checkpoint('hasFeature','CharIsUTF8')
    FeatureList.CharIsUTF8 = CharIsUTF8;
end
tf = FeatureList.(feature);
end
function v000=ifversion(v001,v002,v003,v004,v005),if nargin<2||nargout>1,...
error('incorrect number of input/output arguments'),end,persistent v006 v007 v008,if ...
isempty(v006),v008=exist('OCTAVE_VERSION','builtin');v006=[100,1] * sscanf(version,'%d.%d',2);
v007={'R13' 605;'R13SP1' 605;'R13SP2' 605;'R14' 700;'R14SP1' 700;'R14SP2' 700;'R14SP3' 701;
'R2006a' 702;'R2006b' 703;'R2007a' 704;'R2007b' 705;'R2008a' 706;'R2008b' 707;'R2009a' 708;
'R2009b' 709;'R2010a' 710;'R2010b' 711;'R2011a' 712;'R2011b' 713;'R2012a' 714;'R2012b' 800;
'R2013a' 801;'R2013b' 802;'R2014a' 803;'R2014b' 804;'R2015a' 805;'R2015b' 806;'R2016a' 900;
'R2016b' 901;'R2017a' 902;'R2017b' 903;'R2018a' 904;'R2018b' 905;'R2019a' 906;'R2019b' 907;
'R2020a' 908;'R2020b' 909;'R2021a' 910;'R2021b' 911;'R2022a' 912;'R2022b' 913;'R2023a' 914;
'R2023b' 2302};end,if v008,if nargin==2,warning('HJW:ifversion:NoOctaveTest',...
['No version test for Octave was provided.',char(10),...
'This function might return an unexpected outcome.']),if isnumeric(v002),v009=...
0.1*v002+0.9*ifversion_f00(v002);v009=round(100*v009);else,v010=ismember(v007(:,1),v002);if ...
sum(v010)~=1,warning('HJW:ifversion:NotInDict',...
'The requested version is not in the hard-coded list.'),v000=NaN;return,else,v009=v007{v010,2};
end,end,elseif nargin==4,[v001,v009]=deal(v003,v004);v009=0.1*v009+0.9*ifversion_f00(v009);v009=...
round(100*v009);else,[v001,v009]=deal(v004,v005);v009=0.1*v009+0.9*ifversion_f00(v009);v009=...
round(100*v009);end,else,if isnumeric(v002),v009=ifversion_f00(v002*100);if mod(v009,10)==0,...
v009=ifversion_f00(v002)*100+mod(v002,1)*10;end,else,v010=ismember(v007(:,1),v002);if ...
sum(v010)~=1,warning('HJW:ifversion:NotInDict',...
'The requested version is not in the hard-coded list.'),v000=NaN;return,else,v009=v007{v010,2};
end,end,end,switch v001,case'==',v000=v006==v009;case'<',v000=v006 < v009;case'<=',v000=v006 <=...
v009;case'>',v000=v006 > v009;case'>=',v000=v006 >=v009;end,end
function v000=ifversion_f00(v000),v000=fix(v000+eps*1e3);end

function out=PatternReplace(in,pattern,rep)
%Functionally equivalent to strrep, but extended to more data types.
% Any input is converted to a row vector.

in = reshape(in,1,[]);
out = in;
if numel(pattern)==0 || numel(pattern)>numel(in)
    % Return input unchanged (apart from the reshape), as strrep does as well.
    return
end

L = true(size(in));
L((end-numel(pattern)+2):end) = false; % Avoid partial matches
for n=1:numel(pattern)
    % For every element of the pattern, look for matches in the data. Keep track of all possible
    % locations of a match by shifting the logical vector.
    % The last n elements should be left unchanged, to avoid false positives with a wrap-around.
    L_n = in==pattern(n);
    L_n = circshift(L_n,[0 1-n]);
    L_n(1:(n-1)) = L(1:(n-1));
    L = L & L_n;
    
    % If there are no matches left (even if n<numel(pat)), the process can be aborted.
    if ~any(L),return,end
end

if numel(rep)==0
    out(L)=[];
    return
end

% For the replacement, we will create a shadow copy with a coded char array. Non-matching values
% will be coded with a space, the first character of a match will be encoded with an asterisk, and
% trailing characters will be encoded with an underscore.
% In the next step, regexprep will be used to perform the replacement, after which indexing can be
% used to compose the final array.
if numel(pattern)>1
    checkpoint('PatternReplace','bsxfun_plus')
    idx = bsxfun_plus(find(L),reshape(1:(numel(pattern)-1),[],1));
else
    idx = find(L);
end
idx = reshape(idx,1,[]);
str = repmat(' ',1,numel(in));
str(idx) = '_';
str( L ) = '*';
NonMatchL = str==' ';

% The regular expression will take care of the lazy pattern matching. This also shifts the number
% of underscores to the length of the replacement array.
str = regexprep(str,'\*_*',['*' repmat('_',1,numel(rep)-1)]);

% We can paste in the non-matching positions. Positions where the replacement should be inserted
% may or may not be correct.
out(str==' ') = in(NonMatchL);

% Now we can paste in all the replacements.
x = strfind(str,'*');
checkpoint('PatternReplace','bsxfun_plus')
idx = bsxfun_plus(x,reshape(0:(numel(rep)-1),[],1));
idx = reshape(idx,1,[]);
out(idx) = repmat(rep,1,numel(x));

% Remove the elements beyond the range of what the resultant array should be.
out((numel(str)+1):end) = [];
end

function out=checkpoint(caller,varargin)
% This function has limited functionality compared to the debugging version.
% (one of the differences being that this doesn't read/write to a file)
% Syntax:
%   checkpoint(caller,dependency)
%   checkpoint(caller,dependency_1,...,dependency_n)
%   checkpoint(caller,checkpoint_flag)
%   checkpoint('reset')
%   checkpoint('read')
%   checkpoint('write_only_to_file_on_read')
%   checkpoint('write_to_file_every_call')

persistent data
if isempty(data)||strcmp(caller,'reset')
    data = struct('total',0,'time',0,'callers',{{}});
end
if strcmp(caller,"read")
    out = data.time;return
end
if nargin==1,return,end
then = now;
for n=1:numel(varargin)
    data.total = data.total+1;
    data.callers = sort(unique([data.callers {caller}]));
    if ~isfield(data,varargin{n}),data.(varargin{n})=0;end
    data.(varargin{n}) = data.(varargin{n})+1;
end
data.time = data.time+ (now-then)*( 24*60*60*1e3 );
data.time = round(data.time);
end

